//   findById(id: string): Promise<MinhaEntidade | null>;
//   findAll(): Promise<MinhaEntidade[]>;
//   create(data: Partial<MinhaEntidade>): Promise<MinhaEntidade>;
//   update(id: string, data: Partial<MinhaEntidade>): Promise<MinhaEntidade>;
//   delete(id: string): Promise<void>;

// async findTicketsRaw(params: {
//   tenantId: number;
//   status: string[];
//   queuesIdsUser: number[];
//   userId: number;
//   isUnread: boolean;
//   isNotAssigned: boolean;
//   isNotViewAssignedTickets: boolean;
//   isSearchParam: boolean;
//   searchParam: string;
//   limit: number;
//   offset: number;
//   profile: string;
//   isExistsQueueTenant: boolean;
//   NotQueueDefinedTicket: boolean;
// }): Promise<{ tickets: Ticket[]; count: number }> {
//   const {
//     tenantId,
//     status,
//     queuesIdsUser,
//     userId,
//     isUnread,
//     isNotAssigned,
//     isNotViewAssignedTickets,
//     isSearchParam,
//     searchParam,
//     limit,
//     offset,
//     profile,
//     isExistsQueueTenant,
//     NotQueueDefinedTicket,
//   } = params;

//   // A query original é muito complexa e usa recursos específicos do PostgreSQL
//   // como jsonb_build_object e count(*) OVER ().
//   // Para manter a funcionalidade exata, usamos $queryRaw.
//   // Os nomes das tabelas e colunas foram ajustados para o padrão do Prisma (PascalCase para tabelas, camelCase para colunas)
//   // e para corresponder ao SQL original (entre aspas duplas).

//   // NOTA: O Prisma.$queryRaw não suporta substituição de parâmetros nomeados (:paramName)
//   // como o Sequelize. É necessário usar interpolação de tags de template (Prisma.sql)
//   // ou passar os parâmetros na ordem correta para $queryRawUnsafe.
//   // Usaremos a tag de template Prisma.sql para segurança e legibilidade.

//   // Prepara as condições dinâmicas para a cláusula WHERE
//   const statusCondition = Prisma.sql`t.status IN (${Prisma.join(status)})`;

//   const queueCondition = Prisma.sql`
//     (
//       (${profile} = 'admin')
//       OR
//       (${isExistsQueueTenant} = true AND t."queueId" IN (${Prisma.join(
//     queuesIdsUser
//   )}))
//       OR
//       (${NotQueueDefinedTicket} = true)
//       OR
//       (t."userId" = ${userId})
//       OR
//       (t."isGroup" = true)
//       OR
//       (${isExistsQueueTenant} = false)
//     )
//   `;

//   const unreadCondition = isUnread
//     ? Prisma.sql`t."unreadMessages" > 0`
//     : Prisma.sql`TRUE`;

//   const notAssignedCondition = isNotAssigned
//     ? Prisma.sql`t."userId" IS NULL`
//     : Prisma.sql`TRUE`;

//   const searchCondition = isSearchParam
//     ? Prisma.sql`
//       (
//         (t.id::text LIKE ${searchParam}) OR
//         (EXISTS (
//           SELECT 1 FROM "Contact" c
//           WHERE c.id = t."contactId" AND
//           (UPPER(c."name") LIKE UPPER(${searchParam}) OR c."number" LIKE ${searchParam})
//         ))
//       )
//     `
//     : Prisma.sql`TRUE`;

//   const viewAssignedCondition = isNotViewAssignedTickets
//     ? Prisma.sql`
//       (
//         (${profile} = 'admin')
//         OR
//         (t."userId" = ${userId} OR t."userId" IS NULL)
//       )
//     `
//     : Prisma.sql`TRUE`; // Se a config estiver desligada, não restringe

//   // Reconstruindo a query com Prisma.sql
//   const query = Prisma.sql`
//     SELECT
//       COUNT(*) OVER () AS count,
//       c."profilePicUrl",
//       c."name",
//       u."name" AS username,
//       q.queue,
//       em."name" AS empresaNome,
//       jsonb_build_object('id', w.id, 'name', w."name") AS whatsapp,
//       t.*
//     FROM "Tickets" t
//     INNER JOIN "Whatsapp" w ON (w.id = t."whatsappId")
//     LEFT JOIN "Contacts" c ON (t."contactId" = c.id)
//     LEFT JOIN "Empresas" em ON (t."empresaId" = em.id)
//     LEFT JOIN "Users" u ON (u.id = t."userId")
//     LEFT JOIN "Queues" q ON (t."queueId" = q.id)

//     WHERE t."tenantId" = ${tenantId}
//     AND c."tenantId" = ${tenantId}
//     AND t."chatFlowId" IS NULL
//     AND ${statusCondition}
//     AND ${queueCondition}
//     AND ${unreadCondition}
//     AND ${notAssignedCondition}
//     AND ${searchCondition}
//     AND ${viewAssignedCondition}
//     ORDER BY
//       CASE t.status
//         WHEN 'pending' THEN 0
//         WHEN 'open' THEN 1
//         WHEN 'closed' THEN 2
//         ELSE 3
//       END,
//       t."updatedAt" DESC
//     LIMIT ${limit} OFFSET ${offset};
//   `;

//   // Executa a query
//   const ticketsRaw: any[] = await prisma.$queryRaw(query);

//   // O Prisma.$queryRaw retorna um array de objetos.
//   // O campo 'count' vem de 'COUNT(*) OVER ()' e está em cada objeto.
//   const count = ticketsRaw.length > 0 ? Number(ticketsRaw[0].count) : 0;

//   // Remove o campo 'count' dos tickets para retornar apenas os dados do ticket
//   const tickets = ticketsRaw.map(({ count, ...ticket }) => ticket as Ticket);

//   return { tickets, count };
// }
