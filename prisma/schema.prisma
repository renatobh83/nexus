// =================================================
// ARQUIVO PRINCIPAL DO SCHEMA - /prisma/schema.prisma
// =================================================
// Este arquivo orquestra a importação dos modelos.
// Não adicione modelos diretamente aqui.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum ChatFlowStatus {
  not_started
  waiting_answer
  in_progress
}

// Definição dos ENUMs para status e tipo de envio, garantindo consistência.
enum MessageStatus {
  pending
  sended
  received
  canceled
}

enum MessageSendType {
  campaign
  chat
  external
  schedule
  bot
  sync
}

// Definição do modelo Setting.
// Armazena configurações personalizadas do tipo chave-valor para cada Tenant.

model Setting {
  id    Int    @id @default(autoincrement())
  key   String // A chave da configuração (ex: 'userCreation', 'checkMsgIsGroup')
  value String // O valor da configuração (ex: 'enabled', 'disabled')

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com Tenant: Uma configuração pertence a um Tenant.
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId Int // Chave estrangeira para o modelo Tenant.

  // --- Índices e Mapeamento ---

  // Cria um índice único para a combinação de 'key' e 'tenantId'.
  // Isso garante que não pode haver duas configurações com a mesma chave
  // para o mesmo tenant, prevenindo dados duplicados e inconsistentes.
  @@unique([key, tenantId])
  // Mapeia este modelo para o nome exato da tabela no seu banco de dados.
  @@map("Settings")
}

// Definição do modelo ApiConfig.
// Armazena configurações para integrações de API externas,
// como tokens de autenticação e URLs de webhook.

// Definição do modelo Email.
// Armazena as credenciais de um servidor SMTP para envio de e-mails,
// com escopo por Tenant.

model Email {
  id        Int     @id @default(autoincrement())
  smtp      String // Endereço do servidor SMTP (ex: smtp.gmail.com)
  senha     String  @db.Text // Senha do e-mail. Será armazenada criptografada.
  email     String // Endereço de e-mail de envio
  portaSMTP Int // Porta do servidor SMTP (ex: 587, 465)
  ssl       Boolean @default(false) // Se a conexão usa SSL
  tsl       String? // Se a conexão usa TLS (geralmente 'true' ou 'false' como string)

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com Tenant: Estas credenciais de e-mail pertencem a um Tenant.
  // A regra onDelete: Cascade garante que, se o Tenant for deletado,
  // estas credenciais também serão removidas.
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId Int    @unique // Garante que um Tenant só pode ter uma configuração de e-mail.

  // --- Mapeamento da Tabela ---
  @@map("Email")
}

model ApiConfig {
  id               String  @id @default(uuid()) @db.Uuid
  name             String // Nome descritivo para a configuração da API
  token            String? // Token de API (opcional)
  authToken        String  @unique // Token de autenticação, deve ser único para segurança
  urlServiceStatus String? // URL para enviar status do serviço (online, offline)
  urlMessageStatus String? // URL para enviar status de mensagens (enviada, recebida)
  isActive         Boolean @default(true)

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com Whatsapp: A configuração de API está associada a uma sessão/conexão.
  session   Whatsapp @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId Int // Chave estrangeira para o modelo Whatsapp.

  // Relação com User: A configuração foi criada ou é gerenciada por um usuário.
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId Int // Chave estrangeira para o modelo User.

  // Relação com Tenant: A configuração pertence a um Tenant.
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId Int // Chave estrangeira para o modelo Tenant.

  // --- Mapeamento da Tabela ---
  @@map("ApiConfigs")
}

// Representa uma única mensagem dentro de um Ticket.
model Message {
  id             String          @id @default(uuid()) @db.Uuid
  messageId      String?         @unique // ID da mensagem vindo da plataforma (WA, IG, etc.)
  ack            Int             @default(1)
  status         String //MessageStatus   @default(pending)
  wabaMediaId    String?
  read           Boolean         @default(false)
  fromMe         Boolean         @default(false)
  body           String          @db.Text // Corpo da mensagem, será armazenado criptografado
  // mediaName      String?
  mediaUrl       String? // Armazena apenas o nome do arquivo, a URL completa é montada no serviço
  mediaType      String?
  reaction       String?
  reactionFromMe String?
  timestamp      BigInt?
  scheduleDate   DateTime?
  sendType       String//MessageSendType @default(chat)
  idFront        String? // ID temporário gerado pelo frontend
  isDeleted      Boolean         @default(false)
  isForwarded    Boolean         @default(false)

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com Ticket: Uma mensagem pertence a um Ticket.
  ticket   Ticket? @relation(fields: [ticketid], references: [id])
  ticketid Int?

  // Relação com Contact: Uma mensagem é de/para um Contact.
  contact   Contact? @relation(fields: [contactId], references: [id])
  contactId Int?

  // Relação com User: Uma mensagem pode ter sido enviada por um User.
  user   User? @relation(fields: [userId], references: [id])
  userId Int?

  // Relação com Tenant: Uma mensagem pertence a um Tenant.
  tenant   Tenant? @relation(fields: [tenantId], references: [id])
  tenantId Int?

  // --- Auto-Relação para Mensagens Citadas (Quoted Messages) ---
  // Uma mensagem pode citar outra mensagem.
  quotedMsg   Message? @relation("QuotedMessages", fields: [quotedMsgId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  quotedMsgId String?  @db.Uuid

  // Uma mensagem pode ser citada por muitas outras mensagens.
  quotes Message[] @relation("QuotedMessages")

  // ESTE BLOCO É ESSENCIAL PARA GERAR O TIPO messageId_tenantId
  @@unique([messageId, tenantId])
  // --- Mapeamento da Tabela ---
  @@map("Messages")
}

model Whatsapp {
  id                 Int      @id @default(autoincrement())
  name               String   @unique
  session            String? // Opcional, pode não ser aplicável a todos os tipos
  qrcode             String? // Opcional, usado para pareamento via QR Code
  status             String? // Ex: 'CONNECTED', 'DISCONNECTED', 'QRCODE'
  battery            String?
  plugged            Boolean?
  isActive           Boolean  @default(true)
  isDeleted          Boolean  @default(false)
  retries            Int?     @default(0)
  isDefault          Boolean  @default(false)
  tokenTelegram      String?
  type               String   @default("whatsapp") // 'whatsapp', 'waba', 'telegram', 'messenger'
  number             String? // Número de telefone associado à conexão
  wppUser            String? // ID do usuário no WhatsApp (ex: '5511999998888@c.us')
  pairingCodeEnabled Boolean  @default(false)
  pairingCode        String?
  phone              Json? // Armazena informações detalhadas do telefone como um objeto JSON
  wabaBSP            String? // Nome do Business Solution Provider (ex: '360dialog')
  tokenAPI           String? // Token para a API oficial do WhatsApp
  tokenHook          String? // Token JWT para autenticar webhooks recebidos
  farewellMessage    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações ---

  // Relação com Tenant: Uma conexão pertence a um Tenant.
  tenant   Tenant @relation(fields: [tenantId], references: [id])
  tenantId Int

  // Relação com ChatFlow: Uma conexão pode ter um ChatFlow padrão.
  // O campo é opcional, então a relação também deve ser.
  chatFlow   ChatFlow? @relation(fields: [chatFlowId], references: [id])
  chatFlowId Int?

  // Relação com Ticket: Uma conexão pode ter muitos tickets.
  tickets    Ticket[]
  apiConfigs ApiConfig[]

  // Mapeia para o nome da tabela existente no banco de dados.
  @@map("Whatsapp")
}

enum ChamadoStatus {
  ABERTO
  EM_ANDAMENTO
  CONCLUIDO
  PAUSADO
}

model Chamado {
  id                Int           @id @default(autoincrement())
  descricao         String?       @db.Text
  assunto           String?       @db.Text
  conclusao         String?       @db.Text
  motivo            String? // Motivo da pausa ou conclusão
  status            ChamadoStatus @default(ABERTO)
  closedAt          DateTime? // Data de fechamento do chamado
  tempoChamado      Int?          @default(0) // Tempo total em milissegundos
  ticketsAssociados Json? // Armazena um array de IDs de tickets relacionados
  comentarios       Json? // Armazena um array de comentários

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com Ticket: Um chamado pode ser originado de um Ticket.
  ticket   Ticket? @relation(fields: [ticketId], references: [id])
  ticketId Int?

  // Relação com Empresa: Um chamado pertence a uma Empresa.
  empresa   Empresa @relation(fields: [empresaId], references: [id])
  empresaId Int

  // Relação com User: Um chamado é atribuído a um User.
  usuario User @relation(fields: [userId], references: [id])
  userId  Int

  // Relação com PauseHistory: Um chamado pode ter vários registros de pausa.
  pauseHistory PauseHistory[]

  // Relação com Media: Um chamado pode ter vários arquivos de mídia anexados.
  media Media[]

  // Relação Muitos-para-Muitos com Contact (via ChamadoContatos).
  contatos   Contact[]   @relation("ChamadoContatos")
  logTickets LogTicket[]

  // --- Mapeamento da Tabela ---
  @@map("Chamados")
}

model ChatFlow {
  id           Int     @id @default(autoincrement())
  name         String  @db.Text // Usa o tipo TEXT do banco para nomes longos
  flow         Json?   @default("{}") // A estrutura do fluxo armazenada como JSON
  isActive     Boolean @default(true)
  isDeleted    Boolean @default(false)
  celularTeste String? @db.Text // Número de celular para testes

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com User: Um ChatFlow é criado ou gerenciado por um User.
  user   User @relation(fields: [userId], references: [id])
  userId Int

  // Relação com Tenant: Um ChatFlow pertence a um Tenant.
  tenant   Tenant @relation(fields: [tenantId], references: [id])
  tenantId Int

  // Relação inversa: Um ChatFlow pode ser o fluxo padrão para muitas conexões de WhatsApp.
  whatsappDefaults Whatsapp[]
  queues           Queue[]
  tickets          Ticket[]

  // --- Mapeamento da Tabela ---
  @@map("ChatFlows")
}

model Contact {
  id               Int       @id @default(autoincrement())
  name             String
  number           String?
  email            String?   @unique
  profilePicUrl    String?
  pushname         String?
  telegramId       BigInt?   @unique
  dtaniversario    DateTime? // Data de aniversário
  identifier       String?
  serializednumber String?   @unique
  isUser           Boolean   @default(false)
  isWAContact      Boolean   @default(false)
  isGroup          Boolean   @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações ---

  // Relação com Ticket: Um Contato pode ter muitos Tickets.
  tickets Ticket[]

  // // Relação com ContactCustomField: Um Contato pode ter muitos campos customizados.
  // customFields     ContactCustomField[]

  // Relação Muitos-para-Muitos com Chamado (via ChamadoContatos).
  chamados Chamado[] @relation("ChamadoContatos")

  // Relação Muitos-para-Muitos com Empresa (via EmpresaContact).
  // Representa em quais empresas este contato está associado.
  // Esta é uma relação explícita, então apontamos para o modelo de junção.
  empresaAssignments EmpresaContact[]
  messages           Message[]

  // Mapeia para o nome da tabela existente.
  @@map("Contacts")
}

model Empresa {
  id            Int     @id @default(autoincrement())
  name          String
  active        Boolean @default(true)
  address       Json? // Endereço da empresa
  identifier    BigInt? @unique // Usamos BigInt para corresponder ao DataTypes.BIGINT
  acessoExterno Json[]  @default([]) // Array de objetos JSON para acessos DDNS
  openTicketIds Int[]   @default([]) // Array de IDs de tickets abertos

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações ---

  // Relação com Tenant: Uma Empresa pertence a um Tenant.
  tenant   Tenant @relation(fields: [tenantId], references: [id])
  tenantId Int

  // Relação com Contact (Responsável): Uma Empresa tem um Contact responsável.
  // A relação é opcional, como indicado por 'allowNull: true'.
  // responsavelContact   Contact? @relation("ResponsavelEmpresa", fields: [responsavelContactId], references: [id])
  responsavelContactId Int?

  // Relação com ResultadoDDNS: Uma Empresa pode ter um resultado de DDNS.
  // A relação é opcional.
  // ResultadoDDNS        ResultadoDDNS? @relation(fields: [resultadoDDNSId], references: [id])
  resultadoDDNSId Int?

  // Relação com EmpresaContrato: Uma Empresa pode ter muitos contratos.
  contratos EmpresaContrato[]

  // Relação com Ticket: Uma Empresa pode estar associada a muitos tickets.
  tickets Ticket[]

  // Relação Muitos-para-Muitos com Contact (via EmpresaContact):
  // Uma Empresa tem muitos contatos associados através da tabela de junção 'EmpresaContact'.
  empresaContacts EmpresaContact[]

  chamado        Chamado[]
  notaFiscals    NotaFiscal[]
  resultadoDDNSs ResultadoDDNS[]

  // Mapeia para o nome da tabela existente.
  @@map("Empresas")
}

// Definição do modelo FastReply.
// Armazena atalhos de texto (respostas rápidas) para serem usados
// por usuários durante o atendimento.

model FastReply {
  id      Int    @id @default(autoincrement())
  key     String // O atalho ou palavra-chave (ex: 'saudacao', '/obrigado')
  message String @db.Text // A mensagem completa a ser enviada

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com User: Uma resposta rápida é criada e pertence a um usuário.
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId Int // Chave estrangeira para o modelo User.

  // Relação com Tenant: A resposta rápida pertence a um Tenant (escopo de dados).
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId Int // Chave estrangeira para o modelo Tenant.

  // --- Índices e Mapeamento ---

  // Cria um índice único para a combinação de 'key' e 'tenantId'.
  // Isso garante que não pode haver duas respostas rápidas com o mesmo atalho
  // para o mesmo tenant, evitando conflitos.
  @@unique([key, tenantId])
  // Mapeia este modelo para o nome exato da tabela no seu banco de dados.
  @@map("FastReply")
}

model EmpresaContact {
  // --- Relações e Chaves Estrangeiras ---

  // Relação com Empresa: Aponta para a empresa à qual este contato está associado.
  empresa   Empresa @relation(fields: [empresaId], references: [id])
  empresaId Int // Chave estrangeira para o modelo Empresa.

  // Relação com Contact: Aponta para o contato que está associado a esta empresa.
  contact   Contact @relation(fields: [contactId], references: [id])
  contactId Int // Chave estrangeira para o modelo Contact.

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Chave Primária e Índices ---

  // Define uma chave primária composta. Isso garante que a combinação de
  // uma empresa e um contato seja única, prevenindo entradas duplicadas.
  @@id([empresaId, contactId])
  // Mapeia este modelo para o nome exato da tabela no seu banco de dados.
  @@map("EmpresaContacts")
}

model EmpresaContrato {
  id           Int      @id @default(autoincrement())
  totalHoras   Int // Total de horas contratadas
  dataContrato DateTime // Data em que o contrato foi firmado

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com Empresa: Um contrato pertence a uma Empresa.
  empresa   Empresa @relation(fields: [empresaId], references: [id])
  empresaId Int // Chave estrangeira para o modelo Empresa.

  // Relação com Tenant: Um contrato pertence a um Tenant.
  tenant   Tenant @relation(fields: [tenantId], references: [id])
  tenantId Int // Chave estrangeira para o modelo Tenant.

  // --- Mapeamento da Tabela ---
  // Mapeia este modelo para o nome exato da tabela no seu banco de dados.
  @@map("EmpresaContrato")
}

model Media {
  id         Int    @id @default(autoincrement())
  url        String // URL ou caminho para o arquivo de mídia
  type       String // Tipo do arquivo (ex: 'image/png', 'application/pdf')
  dadosenvio Json // Metadados sobre o envio, armazenados como JSON

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com Chamado: Uma mídia pertence a um Chamado.
  chamado   Chamado @relation(fields: [chamadoId], references: [id])
  chamadoId Int // Chave estrangeira para o modelo Chamado.

  // --- Mapeamento da Tabela ---
  // Mapeia este modelo para o nome exato da tabela no seu banco de dados.
  @@map("Media")
}

model PauseHistory {
  id        Int       @id @default(autoincrement())
  startTime DateTime // Momento em que a pausa começou
  endTime   DateTime? // Momento em que a pausa terminou (opcional, pois pode estar em andamento)

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com Chamado: Este registro de pausa pertence a um Chamado.
  // A regra onDelete: Cascade garante que, se o Chamado for deletado,
  // todos os seus registros de pausa também serão deletados automaticamente.
  chamado   Chamado @relation(fields: [chamadoId], references: [id], onDelete: Cascade)
  chamadoId Int // Chave estrangeira para o modelo Chamado.

  // --- Mapeamento da Tabela ---
  @@map("PauseHistories")
}

model Queue {
  id       Int     @id @default(autoincrement())
  queue    String // Nome da fila
  isActive Boolean @default(true)

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relação com Tenant: Uma fila pertence a um Tenant.
  tenant   Tenant @relation(fields: [tenantId], references: [id])
  tenantId Int // Chave estrangeira para o modelo Tenant.

  // Relação Muitos-para-Muitos com User (via UsersQueues).
  // Representa quais usuários são membros desta fila.
  // Esta é uma relação explícita, então apontamos para o modelo de junção.
  userAssignments UsersQueues[]

  tickets   Ticket[]
  chatFlows ChatFlow[]

  logTickets LogTicket[]

  // --- Mapeamento da Tabela ---
  @@map("Queues")
}

// Definição do modelo Integracoes.
// Armazena configurações para diversas integrações de terceiros
// (ex: RD Station, PipeDrive, etc.), com escopo por Tenant.

model Integracoes {
  id          Int    @id @default(autoincrement())
  name        String // Nome da integração (ex: 'RDStation', 'Asaas')
  config_json Json // Objeto JSON contendo as configurações específicas (tokens, chaves, etc.)

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com Tenant: Uma integração pertence a um Tenant.
  // A regra onDelete: Cascade garante que, se o Tenant for deletado,
  // suas configurações de integração também serão removidas.
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId Int // Chave estrangeira para o modelo Tenant.

  // --- Índices e Mapeamento ---

  // Cria um índice único para a combinação de 'name' e 'tenantId'.
  // Isso garante que um tenant não possa ter duas configurações para a mesma
  // integração (ex: duas configurações 'RDStation'), prevenindo inconsistências.
  @@unique([name, tenantId])
  // Mapeia este modelo para o nome exato da tabela no seu banco de dados.
  @@map("Integracoes")
}

model Tenant {
  id                   Int     @id @default(autoincrement())
  status               String  @default("active")
  name                 String
  businessHours        Json    @default("{}") // Armazena horários de funcionamento
  messageBusinessHours String? // Mensagem para fora do horário de expediente
  address              Json? // Endereço do tenant como um objeto JSON
  dadosNfe             Json? // Dados para Nota Fiscal Eletrônica como JSON

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações ---

  // Relação com User (Proprietário): Um Tenant pertence a um User (owner).
  // Esta é a parte "muitos-para-um" da relação.
  //   owner                User     @relation("TenantOwner", fields: [ownerId], references: [id]  ownerId              Int      // Chave estrangeira para o User proprietário

  // Relação com EmpresaContrato: Um Tenant pode ter muitos contratos.
  // Este é o lado "um" da relação "um-para-muitos".
  contratos EmpresaContrato[]

  // Relação com Empresa: Um Tenant pode ter muitas empresas.
  empresas Empresa[]

  // Relação com Whatsapp: Um Tenant pode ter muitas conexões de WhatsApp.
  // (Assumindo que você adicionará esta relação baseada nos outros modelos)
  whatsapps Whatsapp[]

  // Relação com User: Um Tenant pode ter muitos usuários.
  // (Esta é a relação inversa do 'belongsTo' no modelo User)
  users       User[]        @relation("TenantMembers")
  chatFlows   ChatFlow[]
  queues      Queue[]
  // ticket Ticket[]
  messages    Message[]
  settings    Setting[]
  apiConfigs  ApiConfig[]
  emails      Email?
  fastReplies FastReply[]
  integracoes Integracoes[]
  logTickets  LogTicket[]
  notaFiscals NotaFiscal[]

  // Mapeia este modelo para o nome exato da tabela no seu banco de dados.
  @@map("Tenants")
  tickets Ticket[]
}

// Definição do modelo LogTicket.
// Funciona como uma trilha de auditoria, registrando eventos e mudanças
// de estado que ocorrem em Tickets e Chamados.

model LogTicket {
  id   Int    @id @default(autoincrement())
  type String @db.Text // Tipo do evento de log (ex: 'create', 'transfer', 'close')

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---
  // As relações são opcionais para permitir flexibilidade no registro de diferentes tipos de eventos.

  // Relação com Chamado: O log pode estar associado a um chamado.
  // onDelete: SetNull -> Se o chamado for deletado, o log não é perdido,
  // apenas a referência a ele é anulada. Importante para auditoria.
  chamado   Chamado? @relation(fields: [chamadoId], references: [id], onDelete: SetNull)
  chamadoId Int?

  // Relação com User: O log foi gerado por uma ação de um usuário.
  user   User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  userId Int?

  // Relação com Queue: O log pode registrar uma mudança de fila.
  queue   Queue? @relation(fields: [queueId], references: [id], onDelete: SetNull)
  queueId Int?

  // Relação com Tenant: O log pertence a um Tenant.
  // onDelete: Cascade -> Se o Tenant for deletado, todos os seus logs são removidos.
  tenant   Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId Int?

  // Relação com Ticket: O log pode estar associado a um ticket.
  ticket   Ticket? @relation(fields: [ticketId], references: [id], onDelete: SetNull)
  ticketId Int?

  // --- Mapeamento da Tabela ---
  @@map("LogTickets")
}

model Ticket {
  // --- Campos Diretos ---
  id                   Int       @id @default(autoincrement()) // Equivalente a: INTEGER, autoIncrement, primaryKey
  status               String    @default("pending")
  unreadMessages       Int? // O '?' torna o campo opcional (pode ser null), como no Sequelize por padrão
  lastMessage          String?
  channel              String?
  answered             Boolean   @default(true)
  isGroup              Boolean   @default(false)
  associatedCalls      Boolean   @default(false)
  isActiveDemand       Boolean   @default(false)
  isFarewellMessage    Boolean   @default(false)
  sendWelcomeFlow      Boolean   @default(true)
  isTransference       Boolean   @default(false)
  lastInteractionBot   DateTime?
  botRetries           Int?
  closedAt             BigInt? // Prisma suporta BigInt para números muito grandes
  lastMessageAt        BigInt?
  startedAttendanceAt  BigInt?
  chamadoId            BigInt?
  lastAbsenceMessageAt DateTime?
  chatClient           Boolean?
  socketId             String?
  stepChatFlow         String? // Equivalente a TEXT
  chatFlowStatus       String    @default("not_started") // Usando o ENUM definido acima
  apiConfig            Json? // Prisma tem um tipo nativo para JSONB

  // --- Timestamps ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt // O Prisma gerencia o 'updatedAt' automaticamente

  // --- Relações e Chaves Estrangeiras (Onde a mágica acontece) ---

  // Relação com User (um Ticket pertence a um User opcional)
  user   User? @relation(fields: [userId], references: [id])
  userId Int? // Chave estrangeira opcional

  // Relação com Contact (um Ticket pertence a um Contact)
  contact   Contact @relation(fields: [contactId], references: [id])
  contactId Int // Chave estrangeira obrigatória

  // Relação com Whatsapp (um Ticket pertence a um Whatsapp opcional)
  whatsapp   Whatsapp? @relation(fields: [whatsappId], references: [id])
  whatsappId Int?

  // Relação com ChatFlow (um Ticket pertence a um ChatFlow opcional)
  chatFlow   ChatFlow? @relation(fields: [chatFlowId], references: [id])
  chatFlowId Int?

  // Relação com Empresa (um Ticket pertence a uma Empresa)
  empresa   Empresa? @relation(fields: [empresaId], references: [id])
  empresaId Int?

  // Relação com Queue (um Ticket pertence a uma Queue opcional)
  queue   Queue? @relation(fields: [queueId], references: [id])
  queueId Int?

  // // Relação com Tenant (um Ticket pertence a um Tenant)
  tenant              Tenant    @relation(fields: [tenantId], references: [id])
  tenantId            Int

  chamado    Chamado[]
  messages   Message[]
  logTickets LogTicket[]

  // Mapeia o nome do modelo para o nome da tabela no banco de dados
  @@map("Tickets")
}

// Definição do modelo NotaFiscal.
// Armazena informações de notas fiscais emitidas, incluindo
// números, protocolos e status de cancelamento.

model NotaFiscal {
  id               Int       @id @default(autoincrement())
  numeroNota       String
  codVerificacao   String
  protocolo        String
  rps              String // Recibo Provisório de Serviços
  cancelada        Boolean   @default(false)
  datacancelamento DateTime?
  status           String? // Status da nota (ex: 'emitida', 'cancelada', 'processando')

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com Tenant: A nota fiscal pertence a um Tenant.
  // onDelete: Restrict -> Impede que um Tenant seja deletado se tiver notas fiscais associadas.
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Restrict)
  tenantId Int

  // Relação com Empresa: A nota fiscal foi emitida para uma Empresa.
  // onDelete: Restrict -> Impede que uma Empresa seja deletada se tiver notas fiscais associadas.
  empresa   Empresa @relation(fields: [empresaId], references: [id], onDelete: Restrict)
  empresaId Int

  // --- Índices e Mapeamento ---

  // Cria um índice único para a combinação de 'numeroNota' e 'tenantId'.
  // Isso garante que não pode haver duas notas com o mesmo número para o mesmo tenant.
  @@unique([numeroNota, tenantId])
  // Mapeia este modelo para o nome exato da tabela no seu banco de dados.
  @@map("NotaFiscal")
}

// Definição do modelo NotaFiscalLog.
// Armazena um registro de eventos e mensagens relacionados ao
// processamento de notas fiscais, servindo como uma trilha de auditoria.

model NotaFiscalLog {
  id        Int    @id @default(autoincrement())
  codigo    String // Código do evento ou erro (ex: 'E160', 'sucesso')
  numeroRps String // Número do RPS ao qual o log se refere
  mensagem  String @db.Text // Mensagem descritiva do evento ou erro

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Índices e Mapeamento ---

  // Adiciona um índice no campo 'numeroRps' para otimizar buscas
  // por todos os logs relacionados a um RPS específico.
  @@index([numeroRps])
  // Mapeia este modelo para o nome exato da tabela no seu banco de dados.
  @@map("NotaFiscalLog")
}

// Definição do modelo ResultadoDDNS.
// Armazena o histórico de resultados de verificações de DNS dinâmico (DDNS)
// para cada empresa, registrando o status em um determinado momento.

model ResultadoDDNS {
  id           Int      @id @default(autoincrement())
  dominio      String // O domínio que foi verificado
  status       String // O status do resultado (ex: 'online', 'offline', 'resolvido')
  verificadoEm DateTime // O timestamp exato de quando a verificação foi realizada

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com Empresa: O resultado da verificação pertence a uma Empresa.
  // onDelete: Cascade -> Se a Empresa for deletada, todos os seus históricos
  // de verificação de DDNS também serão removidos.
  empresa   Empresa @relation(fields: [empresaId], references: [id], onDelete: Cascade)
  empresaId Int

  // --- Índices e Mapeamento ---

  // Adiciona um índice no campo 'empresaId' para otimizar a busca
  // por todos os resultados de DDNS de uma empresa específica.
  @@index([empresaId])
  // Mapeia este modelo para o nome exato da tabela no seu banco de dados.
  @@map("ResultadoDDNS")
}

model User {
  // --- Campos Diretos ---
  id           Int       @id @default(autoincrement())
  name         String
  email        String    @unique
  status       String?
  passwordHash String? // O campo que realmente existe no banco
  tokenVersion Int?      @default(0)
  profile      String?
  ativo        Boolean   @default(true)
  lastLogin    DateTime?
  lastOnline   DateTime?
  lastLogout   DateTime?
  isOnline     Boolean   @default(false)
  configs      Json? // Suporte nativo para JSON

  // --- Timestamps ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relações ---

  // Relação com Tenant (um User pertence a um Tenant)
  tenant   Tenant @relation("TenantMembers", fields: [tenantId], references: [id])
  tenantId Int

  //  ownedTenants Tenant[] @relation("TenantOwner")
  // Relações Inversas (um User tem muitos...)
  tickets    Ticket[]
  chamados   Chamado[] // Supondo que exista um modelo Chamado
  chatFlow   ChatFlow[]
  // Relação Muitos-para-Muitos (M-N) com Queue
  // A relação agora aponta para o modelo da tabela de junção.
  // Um usuário tem uma lista de "atribuições de fila".
  queues     UsersQueues[]
  messages   Message[]
  apiConfigs ApiConfig[]

  fastReplies FastReply[]
  logTickets  LogTicket[]

  @@map("Users") // Mapeia para a tabela "Users"
}

model UsersQueues {
  // Relação com User, usando o campo 'userId'
  user   User @relation(fields: [userId], references: [id])
  userId Int

  // Relação com Queue, usando o campo 'queueId'
  queue   Queue @relation(fields: [queueId], references: [id])
  queueId Int

  // --- Timestamps ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Define a chave primária composta, que é a combinação de userId e queueId.
  // Isso espelha a estrutura de uma tabela de junção padrão.
  @@id([userId, queueId])
  // Mapeia este modelo para o nome exato da tabela no seu banco de dados.
  // Crucial para que o Prisma encontre a tabela correta.
  @@map("UsersQueues")
}
