// =================================================
// ARQUIVO PRINCIPAL DO SCHEMA - /prisma/schema.prisma
// =================================================
// Este arquivo orquestra a importação dos modelos.
// Não adicione modelos diretamente aqui.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")

}

enum ChatFlowStatus {
  not_started
  waiting_answer
  in_progress
}

model User {
  // --- Campos Diretos ---
  id           Int       @id @default(autoincrement())
  name         String
  email        String    @unique
  status       String?
  passwordHash String?   // O campo que realmente existe no banco
  tokenVersion Int       @default(0)
  profile      String?
  ativo        Boolean   @default(true)
  lastLogin    DateTime?
  lastOnline   DateTime?
  lastLogout   DateTime?
  isOnline     Boolean   @default(false)
  configs      Json?     // Suporte nativo para JSON

  // --- Timestamps ---
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // --- Relações ---

  // Relação com Tenant (um User pertence a um Tenant)
   tenant   Tenant @relation("TenantMembers", fields: [tenantId], references: [id])
  tenantId     Int

  ownedTenants Tenant[] @relation("TenantOwner")
  // Relações Inversas (um User tem muitos...)
  tickets      Ticket[]
  chamados     Chamado[] // Supondo que exista um modelo Chamado
  chatFlow ChatFlow[]
  // Relação Muitos-para-Muitos (M-N) com Queue
  // A relação agora aponta para o modelo da tabela de junção.
  // Um usuário tem uma lista de "atribuições de fila".
  queues UsersQueues[]

  @@map("Users") // Mapeia para a tabela "Users"
}

model Queue {
  id       Int     @id @default(autoincrement())
  queue    String  // Nome da fila
  isActive Boolean @default(true)

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt


  // Relação com Tenant: Uma fila pertence a um Tenant.
  tenant   Tenant  @relation(fields: [tenantId], references: [id])
  tenantId Int     // Chave estrangeira para o modelo Tenant.

  // Relação Muitos-para-Muitos com User (via UsersQueues).
  // Representa quais usuários são membros desta fila.
  // Esta é uma relação explícita, então apontamos para o modelo de junção.
  userAssignments UsersQueues[]

  tickets  Ticket[]
  chatFlows            ChatFlow[]

  // --- Mapeamento da Tabela ---
  @@map("Queues")
}

model Tenant {
  id                   Int      @id @default(autoincrement())
  status               String   @default("active")
  name                 String
  businessHours        Json     @default("{}") // Armazena horários de funcionamento
  messageBusinessHours String?  // Mensagem para fora do horário de expediente
  address              Json?    // Endereço do tenant como um objeto JSON
  dadosNfe             Json?    // Dados para Nota Fiscal Eletrônica como JSON

  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // --- Relações ---

  // Relação com User (Proprietário): Um Tenant pertence a um User (owner).
  // Esta é a parte "muitos-para-um" da relação.
   owner                User     @relation("TenantOwner", fields: [ownerId], references: [id])
  ownerId              Int      // Chave estrangeira para o User proprietário

  // Relação com EmpresaContrato: Um Tenant pode ter muitos contratos.
  // Este é o lado "um" da relação "um-para-muitos".
  contratos            EmpresaContrato[]

  // Relação com Empresa: Um Tenant pode ter muitas empresas.
  empresas             Empresa[]

  // Relação com Whatsapp: Um Tenant pode ter muitas conexões de WhatsApp.
  // (Assumindo que você adicionará esta relação baseada nos outros modelos)
  whatsapps            Whatsapp[]

  // Relação com User: Um Tenant pode ter muitos usuários.
  // (Esta é a relação inversa do 'belongsTo' no modelo User)
  users                User[] @relation("TenantMembers")
  chatFlows            ChatFlow[]
  queues               Queue[]
  ticket Ticket[]

  // Mapeia este modelo para o nome exato da tabela no seu banco de dados.
  @@map("Tenants")
}

model UsersQueues {
  // Relação com User, usando o campo 'userId'
  user   User @relation(fields: [userId], references: [id])
  userId Int

  // Relação com Queue, usando o campo 'queueId'
  queue   Queue @relation(fields: [queueId], references: [id])
  queueId Int

  // Define a chave primária composta, que é a combinação de userId e queueId.
  // Isso espelha a estrutura de uma tabela de junção padrão.
  @@id([userId, queueId])

  // Mapeia este modelo para o nome exato da tabela no seu banco de dados.
  // Crucial para que o Prisma encontre a tabela correta.
  @@map("UsersQueues")
}


model Empresa {
  id                   Int      @id @default(autoincrement())
  name                 String
  active               Boolean  @default(true)
  address              Json?    // Endereço da empresa
  identifier           BigInt?  // Usamos BigInt para corresponder ao DataTypes.BIGINT
  acessoExterno        Json[]   @default([]) // Array de objetos JSON para acessos DDNS
  openTicketIds        Int[]    @default([]) // Array de IDs de tickets abertos

  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // --- Relações ---

  // Relação com Tenant: Uma Empresa pertence a um Tenant.
  tenant               Tenant   @relation(fields: [tenantId], references: [id])
  tenantId             Int

  // Relação com Contact (Responsável): Uma Empresa tem um Contact responsável.
  // A relação é opcional, como indicado por 'allowNull: true'.
  // responsavelContact   Contact? @relation("ResponsavelEmpresa", fields: [responsavelContactId], references: [id])
  responsavelContactId Int?

  // Relação com ResultadoDDNS: Uma Empresa pode ter um resultado de DDNS.
  // A relação é opcional.
  // ResultadoDDNS        ResultadoDDNS? @relation(fields: [resultadoDDNSId], references: [id])
  resultadoDDNSId      Int?

  // Relação com EmpresaContrato: Uma Empresa pode ter muitos contratos.
  contratos            EmpresaContrato[]

  // Relação com Ticket: Uma Empresa pode estar associada a muitos tickets.
  tickets              Ticket[]

  // Relação Muitos-para-Muitos com Contact (via EmpresaContact):
  // Uma Empresa tem muitos contatos associados através da tabela de junção 'EmpresaContact'.
  empresaContacts      EmpresaContact[]

  chamado Chamado[]

  // Mapeia para o nome da tabela existente.
  @@map("Empresas")
}
model EmpresaContrato {
  id           Int      @id @default(autoincrement())
  totalHoras   Int      // Total de horas contratadas
  dataContrato DateTime // Data em que o contrato foi firmado

  // --- Metadados ---
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com Empresa: Um contrato pertence a uma Empresa.
  empresa      Empresa  @relation(fields: [empresaId], references: [id])
  empresaId    Int      // Chave estrangeira para o modelo Empresa.

  // Relação com Tenant: Um contrato pertence a um Tenant.
  tenant       Tenant   @relation(fields: [tenantId], references: [id])
  tenantId     Int      // Chave estrangeira para o modelo Tenant.

  // --- Mapeamento da Tabela ---
  // Mapeia este modelo para o nome exato da tabela no seu banco de dados.
  @@map("EmpresaContrato")
}

model EmpresaContact {
  // --- Relações e Chaves Estrangeiras ---

  // Relação com Empresa: Aponta para a empresa à qual este contato está associado.
  empresa   Empresa @relation(fields: [empresaId], references: [id])
  empresaId Int     // Chave estrangeira para o modelo Empresa.

  // Relação com Contact: Aponta para o contato que está associado a esta empresa.
  contact   Contact @relation(fields: [contactId], references: [id])
  contactId Int     // Chave estrangeira para o modelo Contact.

  // --- Metadados ---
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Chave Primária e Índices ---

  // Define uma chave primária composta. Isso garante que a combinação de
  // uma empresa e um contato seja única, prevenindo entradas duplicadas.
  @@id([empresaId, contactId])

  // Mapeia este modelo para o nome exato da tabela no seu banco de dados.
  @@map("EmpresaContacts")
}

model Contact {
  id               Int       @id @default(autoincrement())
  name             String
  number           String?
  email            String?
  profilePicUrl    String?
  pushname         String?
  telegramId       String?
  dtaniversario    DateTime? // Data de aniversário
  identifier       String?
  serializednumber String?   @default("")
  isUser           Boolean   @default(false)
  isWAContact      Boolean   @default(false)
  isGroup          Boolean   @default(false)

  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // --- Relações ---

  // Relação com Ticket: Um Contato pode ter muitos Tickets.
  tickets          Ticket[]

  // // Relação com ContactCustomField: Um Contato pode ter muitos campos customizados.
  // customFields     ContactCustomField[]

  // Relação Muitos-para-Muitos com Chamado (via ChamadoContatos).
  chamados         Chamado[] @relation("ChamadoContatos")

  // Relação Muitos-para-Muitos com Empresa (via EmpresaContact).
  // Representa em quais empresas este contato está associado.
  // Esta é uma relação explícita, então apontamos para o modelo de junção.
  empresaAssignments EmpresaContact[]

  // Mapeia para o nome da tabela existente.
  @@map("Contacts")
}

model Ticket {
  // --- Campos Diretos ---
  id                  Int       @id @default(autoincrement()) // Equivalente a: INTEGER, autoIncrement, primaryKey
  status              String    @default("pending")
  unreadMessages      Int?      // O '?' torna o campo opcional (pode ser null), como no Sequelize por padrão
  lastMessage         String?
  channel             String?
  answered            Boolean   @default(true)
  isGroup             Boolean   @default(false)
  associatedCalls     Boolean   @default(false)
  isActiveDemand      Boolean   @default(false)
  isFarewellMessage   Boolean   @default(false)
  sendWelcomeFlow     Boolean   @default(true)
  lastInteractionBot  DateTime?
  botRetries          Int?
  closedAt            BigInt?   // Prisma suporta BigInt para números muito grandes
  lastMessageAt       BigInt?
  startedAttendanceAt BigInt?
  chamadoId           BigInt?
  lastAbsenceMessageAt DateTime?
  chatClient          Boolean?
  socketId            String?
  stepChatFlow        String?   // Equivalente a TEXT
  chatFlowStatus      ChatFlowStatus @default(not_started) // Usando o ENUM definido acima
  apiConfig           Json?     // Prisma tem um tipo nativo para JSONB

  // --- Timestamps ---
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt // O Prisma gerencia o 'updatedAt' automaticamente

  // --- Relações e Chaves Estrangeiras (Onde a mágica acontece) ---

  // Relação com User (um Ticket pertence a um User opcional)
  user                User?     @relation(fields: [userId], references: [id])
  userId              Int?      // Chave estrangeira opcional

  // Relação com Contact (um Ticket pertence a um Contact)
  contact             Contact   @relation(fields: [contactId], references: [id])
  contactId           Int       // Chave estrangeira obrigatória

  // Relação com Whatsapp (um Ticket pertence a um Whatsapp opcional)
  whatsapp            Whatsapp? @relation(fields: [whatsappId], references: [id])
  whatsappId          Int?

  // Relação com ChatFlow (um Ticket pertence a um ChatFlow opcional)
  chatFlow            ChatFlow? @relation(fields: [chatFlowId], references: [id])
  chatFlowId          Int?

  // Relação com Empresa (um Ticket pertence a uma Empresa)
  empresa             Empresa   @relation(fields: [empresaId], references: [id])
  empresaId           Int

  // Relação com Queue (um Ticket pertence a uma Queue opcional)
  queue     Queue? @relation(fields: [queueId], references: [id])
  queueId   Int?

  // Relação com Tenant (um Ticket pertence a um Tenant)
  tenant              Tenant    @relation(fields: [tenantId], references: [id])
  tenantId            Int

  // Relação com Message (um Ticket tem muitas Messages)
  // messages            Message[]
  chamado Chamado[]

  // Mapeia o nome do modelo para o nome da tabela no banco de dados
  @@map("Tickets")
}


model ChatFlow {
  id           Int      @id @default(autoincrement())
  name         String   @db.Text // Usa o tipo TEXT do banco para nomes longos
  flow         Json?    @default("{}") // A estrutura do fluxo armazenada como JSON
  isActive     Boolean  @default(true)
  isDeleted    Boolean  @default(false)
  celularTeste String?  @db.Text // Número de celular para testes

  // --- Metadados ---
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com User: Um ChatFlow é criado ou gerenciado por um User.
  user         User     @relation(fields: [userId], references: [id])
  userId       Int

  // Relação com Tenant: Um ChatFlow pertence a um Tenant.
  tenant       Tenant   @relation(fields: [tenantId], references: [id])
  tenantId     Int

  // Relação inversa: Um ChatFlow pode ser o fluxo padrão para muitas conexões de WhatsApp.
  whatsappDefaults Whatsapp[]
  queues            Queue[]
   tickets      Ticket[]

  // --- Mapeamento da Tabela ---
  @@map("ChatFlows")
}


model Whatsapp {
  id                 Int      @id @default(autoincrement())
  name               String   @unique
  session            String?  // Opcional, pode não ser aplicável a todos os tipos
  qrcode             String?  // Opcional, usado para pareamento via QR Code
  status             String?  // Ex: 'CONNECTED', 'DISCONNECTED', 'QRCODE'
  battery            String?
  plugged            Boolean?
  isActive           Boolean  @default(true)
  isDeleted          Boolean  @default(false)
  retries            Int?     @default(0)
  isDefault          Boolean  @default(false)
  tokenTelegram      String?
  type               String   @default("whatsapp") // 'whatsapp', 'waba', 'telegram', 'messenger'
  number             String?  // Número de telefone associado à conexão
  wppUser            String?  // ID do usuário no WhatsApp (ex: '5511999998888@c.us')
  pairingCodeEnabled Boolean  @default(false)
  pairingCode        String?
  phone              Json?    // Armazena informações detalhadas do telefone como um objeto JSON
  wabaBSP            String?  // Nome do Business Solution Provider (ex: '360dialog')
  tokenAPI           String?  // Token para a API oficial do WhatsApp
  tokenHook          String?  // Token JWT para autenticar webhooks recebidos
  farewellMessage    String?

  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // --- Relações ---

  // Relação com Tenant: Uma conexão pertence a um Tenant.
  tenant             Tenant   @relation(fields: [tenantId], references: [id])
  tenantId           Int

  // Relação com ChatFlow: Uma conexão pode ter um ChatFlow padrão.
  // O campo é opcional, então a relação também deve ser.
  chatFlow           ChatFlow? @relation(fields: [chatFlowId], references: [id])
  chatFlowId         Int?

  // Relação com Ticket: Uma conexão pode ter muitos tickets.
  tickets            Ticket[]

  // Mapeia para o nome da tabela existente no banco de dados.
  @@map("Whatsapp")
}

enum ChamadoStatus {
  ABERTO
  EM_ANDAMENTO
  CONCLUIDO
  PAUSADO
}

model Chamado {
  id                Int           @id @default(autoincrement())
  descricao         String?       @db.Text
  assunto           String?       @db.Text
  conclusao         String?       @db.Text
  motivo            String?       // Motivo da pausa ou conclusão
  status            ChamadoStatus @default(ABERTO)
  closedAt          DateTime?     // Data de fechamento do chamado
  tempoChamado      Int?          @default(0) // Tempo total em milissegundos
  ticketsAssociados Json?         // Armazena um array de IDs de tickets relacionados
  comentarios       Json?         // Armazena um array de comentários

  // --- Metadados ---
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com Ticket: Um chamado pode ser originado de um Ticket.
  ticket            Ticket?       @relation(fields: [ticketId], references: [id])
  ticketId          Int?

  // Relação com Empresa: Um chamado pertence a uma Empresa.
  empresa           Empresa       @relation(fields: [empresaId], references: [id])
  empresaId         Int

  // Relação com User: Um chamado é atribuído a um User.
  usuario           User          @relation(fields: [userId], references: [id])
  userId            Int

  // Relação com PauseHistory: Um chamado pode ter vários registros de pausa.
  pauseHistory      PauseHistory[]

  // Relação com Media: Um chamado pode ter vários arquivos de mídia anexados.
  media             Media[]

  // Relação Muitos-para-Muitos com Contact (via ChamadoContatos).
  contatos          Contact[]     @relation("ChamadoContatos")

  // --- Mapeamento da Tabela ---
  @@map("Chamados")
}

model Media {
  id         Int      @id @default(autoincrement())
  url        String   // URL ou caminho para o arquivo de mídia
  type       String   // Tipo do arquivo (ex: 'image/png', 'application/pdf')
  dadosenvio Json     // Metadados sobre o envio, armazenados como JSON

  // --- Metadados ---
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com Chamado: Uma mídia pertence a um Chamado.
  chamado    Chamado  @relation(fields: [chamadoId], references: [id])
  chamadoId  Int      // Chave estrangeira para o modelo Chamado.

  // --- Mapeamento da Tabela ---
  // Mapeia este modelo para o nome exato da tabela no seu banco de dados.
  @@map("Media")
}

model PauseHistory {
  id        Int       @id @default(autoincrement())
  startTime DateTime  // Momento em que a pausa começou
  endTime   DateTime? // Momento em que a pausa terminou (opcional, pois pode estar em andamento)

  // --- Metadados ---
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // --- Relações e Chaves Estrangeiras ---

  // Relação com Chamado: Este registro de pausa pertence a um Chamado.
  // A regra onDelete: Cascade garante que, se o Chamado for deletado,
  // todos os seus registros de pausa também serão deletados automaticamente.
  chamado   Chamado   @relation(fields: [chamadoId], references: [id], onDelete: Cascade)
  chamadoId Int       // Chave estrangeira para o modelo Chamado.

  // --- Mapeamento da Tabela ---
  @@map("PauseHistories")
}